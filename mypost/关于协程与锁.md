### 原文1

http://t.cn/zRoX32P 在stackoverflow上问了下，gevent的只有在遇到io操作时才会切换到其它的协程，而·count+=1·虽然有三步操作（取值，+1，赋值），但没有io操作，使用gevent的话这段代码是线程安全的，不需要加锁，我理解的对吗？go的协程也是这样吗？还是想Erlang一样 @许式伟 @GeniusVczh


### 讨论

**刘鑫-Mars：**
上下文切换可以sleep，另外那个不叫线程安全，gevent的模式不是靠线程切换上下文，这个东西的切换方式类似 @GeniusVczh 前几天在知乎上解释的模型，在当前协程阻塞的时候实际上是去尝试切换到其它的协程。这个python问题at了两个CPP工程大概没问对人：）     (10月30日 11:31)

**蛙蛙王子：**
我这不是借个概念用一下吗，协程也好，线程也好，切换到时候肯定要把栈上的信息暂存一下呀，要不切回来怎么继续执行呀。那叫协程安全好了。     (10月30日 11:43)


**蛙蛙王子：**
我at他俩是之前讨论个这个问题，我只想说有些语句在多线程环境下必须加锁，而在多协程下不一定非要加锁，要具体分析，不能不明不白的加锁

**刘鑫-Mars：**
协程几乎不需要加锁，小心点别阻塞是更重要的问题。 (10月30日 11:50)

**蛙蛙王子：**
对，这个是，主要是防止一些不能被gevent patch的c库 (10月30日 12:03)

**ukessi：**
看看python源码吧，或者《python源码解析》也可以，除了阻塞操作会释放GIL切换线程，执行了一定数量的python vm指令也会释放GIL切换线程，+=1三条指令不加锁还是有机会被切换的     (10月30日 12:20)

**蛙蛙王子：**
对，python thread需要加锁，我代码里不是说了吗？    (10月30日 13:01)

**师傅被大师兄捉走了：**
调度的时机是由实现决定的。比如旧版的Go Runtime只有在阻塞调用的时候才会发生调度，而新版的Runtime在函数调用的时候也会随机发生调度。所以当作普通的线程看待就好了，用户代码不要依赖调度器的底层实现。     (10月30日 12:23)

**师傅被大师兄捉走了：**
Python的多线程确实是操作系统线程，这个和一般的单线程协程模型是不一样的。Python的GIL是指在操作Python对象的时候会加一把全局的锁，这导致多线程操作Python对象时只能串行执行。但是执行IO前，这把锁会被释放，其它线程就可以得到锁，从而继续运行。   (10月30日 12:32)

**师傅被大师兄捉走了:**
所以Python的线程都是同时运行的，只是其它线程会等待锁。没有发生IO时调度的过程。这个和gevent的机制不一样。   (10月30日 12:36)

**师傅被大师兄捉走了:**
补充一下Go的，Go现在只会在函数调用时调度，但是也不能保证没有函数调用就不会调度。要是编译器可以识别出一个可能会执行很长时间的循环，在循环内自动插入调用调度器的代码也不是不可能的。所以该加锁就加锁吧。     (10月30日 12:40)
