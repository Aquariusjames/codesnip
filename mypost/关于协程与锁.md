### 原文1

http://t.cn/zRoX32P 在stackoverflow上问了下，gevent的只有在遇到io操作时才会切换到其它的协程，而·count+=1·虽然有三步操作（取值，+1，赋值），但没有io操作，使用gevent的话这段代码是线程安全的，不需要加锁，我理解的对吗？go的协程也是这样吗？还是想Erlang一样 @许式伟 @GeniusVczh

只有**师傅被大师兄捉走了**说的最切题，最深入。

### 讨论

**刘鑫-Mars：**
上下文切换可以sleep，另外那个不叫线程安全，gevent的模式不是靠线程切换上下文，这个东西的切换方式类似 @GeniusVczh 前几天在知乎上解释的模型，在当前协程阻塞的时候实际上是去尝试切换到其它的协程。这个python问题at了两个CPP工程大概没问对人：）     (10月30日 11:31)

**蛙蛙王子：**
我这不是借个概念用一下吗，协程也好，线程也好，切换到时候肯定要把栈上的信息暂存一下呀，要不切回来怎么继续执行呀。那叫协程安全好了。     (10月30日 11:43)


**蛙蛙王子：**
我at他俩是之前讨论个这个问题，我只想说有些语句在多线程环境下必须加锁，而在多协程下不一定非要加锁，要具体分析，不能不明不白的加锁

**刘鑫-Mars：**
协程几乎不需要加锁，小心点别阻塞是更重要的问题。 (10月30日 11:50)

**蛙蛙王子：**
对，这个是，主要是防止一些不能被gevent patch的c库 (10月30日 12:03)

**ukessi：**
看看python源码吧，或者《python源码解析》也可以，除了阻塞操作会释放GIL切换线程，执行了一定数量的python vm指令也会释放GIL切换线程，+=1三条指令不加锁还是有机会被切换的     (10月30日 12:20)

**蛙蛙王子：**
对，python thread需要加锁，我代码里不是说了吗？    (10月30日 13:01)

**师傅被大师兄捉走了：**
调度的时机是由实现决定的。比如旧版的Go Runtime只有在阻塞调用的时候才会发生调度，而新版的Runtime在函数调用的时候也会随机发生调度。所以当作普通的线程看待就好了，用户代码不要依赖调度器的底层实现。     (10月30日 12:23)

**师傅被大师兄捉走了：**
Python的多线程确实是操作系统线程，这个和一般的单线程协程模型是不一样的。Python的GIL是指在操作Python对象的时候会加一把全局的锁，这导致多线程操作Python对象时只能串行执行。但是执行IO前，这把锁会被释放，其它线程就可以得到锁，从而继续运行。   (10月30日 12:32)

**师傅被大师兄捉走了:**
所以Python的线程都是同时运行的，只是其它线程会等待锁。没有发生IO时调度的过程。这个和gevent的机制不一样。   (10月30日 12:36)

**师傅被大师兄捉走了:**
补充一下Go的，Go现在只会在函数调用时调度，但是也不能保证没有函数调用就不会调度。要是编译器可以识别出一个可能会执行很长时间的循环，在循环内自动插入调用调度器的代码也不是不可能的。所以该加锁就加锁吧。     (10月30日 12:40)


### 原文2

看了几天书，终于明白单核cpu上的多线程或多协程程序为什么也要加锁了，是为了防止出现脏读或竞争条件，一个变量确实不会被同时读写，但一些顺序的语句或指令可能被打乱执行，从而破坏程序逻辑…@许式伟

原帖的*打乱执行*用词不够准确，造成了很多人的误解，但 **寒冬winter**, **空明流转wy**等同学的回复挺好。

### 讨论

**许式伟：**
不是乱序执行的问题，还要再看几天书。     (10月28日 10:30)

**ibuick：**
汗，，这是看了啥书啊，，，，怎么会得出这种结论，     (10月28日 10:42)

**蛙蛙王子：**
我说的乱序不是cpu指令集优化的那个乱序，我是说一个函数的代码可能会被多个线程你一句我一句的执行  (10月28日 11:26)    

**许式伟：**
嗯，不小心用了cpu的乱序执行的概念，被我误解了     (10月28日 11:32)

**holly_lee**
哎, 看上去线程是怎么被调度的还没搞明白

**老赵：**
哪有那么复杂。道理很简单，单核单CPU执行多线程也是一会儿这个一会儿那个的啊。

**RuPyCer：**
多线程加锁是系统调度造成的，cpu乱序执行要靠memoru barrier解决，这是两码事儿

**陈容_Rong：**
简单问题被复杂化，单核不是关键，多线程才是关键。

**空明流转wy：**
只不过单核上很多操作不用做barrier，有些指令也是天然原子的罢了。 

**寒冬winter：**
应该叫并行或者穿插执行，

### 原文3

http://t.cn/zRaM90n Talk Is Cheap 我写了一段代码来测试多线程和单线程多协程情况下的竞争条件，结论是有些协程的实现确实不需要加锁，因为他们根本就模拟不了真正的操作系统线程。@许式伟 @ibuick @GeniusVczh

同样的代码用python线程就可以很快出现竞争条件，用gevent的协程就没有出现，回帖的人没去想为什么会这样，全是调侃的。
其实gevent的调度方式是遇到io操作才切换到别的协程，所以例子的代码真的跑100年也不会出现竞争条件，但gevent改进了调度方式就真不一定了。

### 讨论

**GeniusVczh：**
要学Jeffrey Richter 跑一个晚上

**许式伟：**
应该跑100年，然后说：我证明了这个竞争百年难以遇到一次，至于第101年会不会遇到竞争，我就不保证了。。。

**老赵：**
多线程问题方面的code只能证明有错不能证明没错，还得靠分析。总之你把简单问题想复杂了。

**GeniusVczh：**
Jeffrey Richter：跑一个晚上都没出问题，就可以着手证明它了

**analystqiaojie：**
最基本的协程概念没搞懂，靠写测试代码来揣测，这是盲人摸象的节奏。

**holly_lee：**
Clarify 一下: 协程的准确定义是什么

**蛙蛙王子：**
我是觉得协程调度可能不会把count+=1拆开，如果不会拆开，就真的不用加锁。

**蛙蛙王子：**
我刚问了下褚霸，说erlang的协程会把count+=1拆开执行，不知道go的协程会原子的执行count+=1还是也会拆开执行？
